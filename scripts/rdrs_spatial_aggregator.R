#' @title RDRS spatial aggregator
#' @description
#' This function is designed for spatial aggregation of RDRS NetCDF files.
#' @param ncFile file path where NetCDF file is located
#' @param weightsFile (optional)  RDRS grid cells weights file path generated by \code{grids_weights_generator}. If missing, a uniform spatial aggregation is performed across the entire domain of the netcdf file.
#' @param hrufile (optional)  a shapefile with a valid CRS. It is used to calculate the grid cell weights using \code{grids_weights_generator}
#' @param varnames (optional)  character vector length-2 of NetCDF variable names (lon, lat), required when shapefile is provided and \code{weightsFile} is missing.
#' @param dimnames (optional)  character vector length-2 of NetCDF dimension names, required when shapefile is provided and \code{weightsFile} is missing.
#' @param HRU_ID (optional)  the name of the hrufile polygon which contains the HRU IDs required when shapefile is provided and \code{weightsFile} is missing.
#' @param OutFile The file path of the output ".csv" file to store the results
#' @return a "csv" object saved in the specified pile path in the \code{OutFile}, if missing the file will be save at the same location of the netcdf file
#' @export rdrs_nc_spatial_aggregator
#' @importFrom ncdf4 nc_open nc_close ncvar_get
#' @examples
#' dir.create("c:/rdrs")
#' setwd("c:/rdrs")
#' source("https://raw.githubusercontent.com/rarabzad/RDRS/main/rdrs_spatial_aggregator.R")
#' # download data
#' download.file("https://github.com/rarabzad/RDRS/raw/main/data/data.zip","data.zip")
#' unzip("data.zip")
#' ncFile<-list.files(pattern="*.nc")[1]
#' rdrs_spatial_aggregator(ncFile=ncFile)
#' @author Rezgar Arabzadeh, University of Waterloo, October 2023
rdrs_spatial_aggregator<-function(ncFile,
                                  weightsFile=NULL,
                                  hrufile = NULL,
                                  varnames = NULL,
                                  dimnames = NULL,
                                  HRU_ID   = NULL)
{
  if(is.null(weightsFile)  & is.null(hrufile)) warning("either grid cells weight file or HRUs shapefile must be provided! otherwise grid cells will be assigned with equal weights.")
  if(!file.exists(ncFile)) stop("provided nc file doesn't exist!")
  if(!grepl("\\.nc$", tolower(ncFile))) stop("for 'ncFile' wrong file format specified. Only '.nc' is accepted!")
  if(!is.null(weightsFile))
  {
    if(!file.exists(weightsFile)) stop("provided weight file doesn't exist!")
    if(!grepl("\\.txt$", tolower(weightsFile))) stop("for 'weightsFile' wrong file format specified. Only '.txt' is accepted!")
  } else if (!is.null(hrufile) & is.null(weightsFile)){
    if(is.null(hrufile)) stop("HRUs shape file must be provided when grid cells weight file is missing!")
    if(is.null(varnames) & is.null(dimnames)) stop("When the grid cell weight file is missing, you must provide either the variable names, the dimensions, or both!")
    if(is.null(HRU_ID)) stop("When the grid cell weight file is missing, you must provide HRU_ID!")
    source("https://raw.githubusercontent.com/rarabzad/GridWeightsGenerator/refs/heads/main/grids_weights_generator.R")
    weights_txt<-
    grids_weights_generator(ncfile=ncFile,
                            hrufile=hrufile,
                            varnames=varnames,
                            dimnames=dimnames,
                            HRU_ID=HRU_ID,
                            plot= FALSE)$weights_txt
    data_lines <- weights_txt[!grepl("^[:#]", weights_txt)]
    weights    <- read.table(text = data_lines, sep = "\t", header = FALSE,
                         col.names = c("spatial_unit","Cell_#","weight"))
    colnames(weights)<-c("spatial_unit","Cell_#","weight")
  } else if (is.null(hrufile) & !is.null(weightsFile)){
    weights<-readLines(weightsFile,warn = F)
    weights<-weights[-grep("^\\s*#", weights)]
    weights<-weights[-grep("^\\s*:", weights)]
    weights<-read.table(text = weights, header = F)
    colnames(weights)<-c("spatial_unit","Cell_#","weight")
  }else if (is.null(hrufile) & is.null(weightsFile)){
    spatial_unit<-gsub(".nc","",basename(ncFile))
    Cell_id<-which(!is.na(ncvar_get(nc,names(nc$var)[sapply(nc$var, function(v) length(v$dim) >= 3)][1])[,,1]))-1
    weight<-1/length(Cell_id)
    weights<-data.frame(spatial_unit,Cell_id,weight)
    colnames(weights)<-c("spatial_unit","Cell_#","weight")
  }
  OutFile<-file.path(dirname(ncFile),gsub(".nc","_aggregated.csv",basename(ncFile)))
  nc<-nc_open(ncFile)
  vars <- names(nc$var)[sapply(nc$var, function(v) length(v$dim) >= 2)]
  space_dims <- names(nc$dim)[grepl("degrees", sapply(nc$dim, `[[`, "units"), ignore.case = TRUE)]
  vars <- vars[sapply(nc$var[vars], function(v) all(space_dims %in% sapply(v$dim, `[[`, "name")))]
  spatial_unit<-unique(weights$spatial_unit)
  time_dim <- nc$dim[
  sapply(nc$dim, function(d) {
    !is.null(d$units) && grepl("since", d$units, ignore.case = TRUE)
  })][[1]]
  time_vals  <- time_dim$vals - 1
  time_units <- time_dim$units
  origin_str <- sub(".*since ", "", time_units)
  time_step<-unit_str   <- tolower(trimws(strsplit(time_units, " since ")[[1]][1]))
  date_time<-origin     <- as.POSIXct(origin_str, tz = "UTC")
  sequence_of_times <- switch(unit_str,
  "seconds" = origin + seconds(time_vals),
  "minutes" = origin + minutes(time_vals),
  "hours"   = origin + hours(time_vals),
  "days"    = origin + days(time_vals),
  "weeks"   = origin + weeks(time_vals),
  "months"  = origin %m+% months(time_vals),
  "years"   = origin %m+% years(time_vals),
  stop(paste("Unsupported time unit:", unit_str)))
  aggregated_data<-list()
  for(j in 1:length(vars))
  {
    cat(paste0("(",j,"/",length(vars),")", " #### Aggregating: ",vars[j]," ####\n"))
    mat <- matrix(NA, nrow = if (length(nc$var[[vars[j]]]$dim) > 2) length(sequence_of_times) else 1, ncol = length(spatial_unit))
    var_data<-ncvar_get(nc,vars[j], collapse_degen = F)
    for(i in 1:length(spatial_unit))
    {
      w<-weights[weights$spatial_unit==spatial_unit[i],"weight"]
      id<-weights[weights$spatial_unit==spatial_unit[i],"Cell_#"]+1
      W<-array(NA,dim(var_data)[1:2])
      W[id]<-w
      W<-array(W, dim = c(dim(W), ifelse(length(dim(var_data))>2,dim(var_data)[3],1)))
      if(dim(W)[3]==1) W<-W[,,1]
      mat[,i]<-
      if(length(dim(W))==2){
        sum(W*var_data,na.rm=T)
      }else{
        apply(W*var_data,3,sum,na.rm=T)
      } 
    }
    mat<-as.data.frame(mat)
    rownames(mat)<-if (length(nc$var[[vars[j]]]$dim) > 2) as.character(sequence_of_times) else NULL
    colnames(mat)<-spatial_unit
    aggregated_data[[j]]<-mat
  }
  names(aggregated_data)<-vars
  aggregated_data<-do.call(cbind, aggregated_data)
  colnames(aggregated_data)<-apply(as.matrix(expand.grid(sprintf("(%s)",spatial_unit),vars)),1,paste, collapse = " ")
  write.csv(aggregated_data,OutFile)
  nc_close(nc)
  cat(paste("output file is saved at:",OutFile,"\n"))
}
